@{
	ViewBag.Title = "RTS Log Parsing Project";
}

<div class="wrapper wrapper-content animated fadeInRight">

	<div class="row">
		<div class="col-lg-12">

			<div class="text-center m-t-lg">
				<h1>Current Metrics From Log</h1>
				<small>Don't worry, be happy.</small>
			</div>

		</div>
	</div>

	<hr />

	<div class="row">

		<!-- World Map -->
		<div class="col-md-12">

			<div class="panel panel-default">
				<div class="panel-heading">
					<h3 class="panel-title">Message Appearance by Country</h3>
				</div>
				<div class="panel-body">
					<div id="regions_div" style="height:800px; max-height:800px;"></div>

				</div>
			</div>

		</div>

		<div class="col-md-4">
			<div class="panel panel-default">
				<div class="panel-heading">
					<h3 class="panel-title">Top 10 Countries</h3>
				</div>
				<div class="panel-body">
					<table class="table table-condensed table-hover table-striped topCountriesTbl">
						<thead>
							<tr>
								<th>Rank</th>
								<th>Country Code</th>
								<th>Total Messages</th>
							</tr>
						</thead>
						<tbody>
						</tbody>
					</table>
				</div>
			</div>
		</div>

		<div class="col-md-8">

			<div class="panel panel-default">
				<div class="panel-heading">
					<h3 class="panel-title">Live Feed</h3>
				</div>
				<div class="panel-body">
					<div class="btn-group">
						<a href="#" class="btn btn-success liveFeedStart">Start</a>
						<a href="#" class="btn btn-danger liveFeedStop">Stop</a>
						<a href="#" class="btn btn-warning liveFeedReset">Reset</a>
					</div>
					<hr/>
					<div class="life-feed-chart" style="height:380px;"></div>
				</div>
			</div>

		</div>

		<!-- Top Three Message Types -->
		<div class="col-md-12">
			<div class="panel panel-default">
				<div class="panel-heading">
					<h3 class="panel-title">Overall Top 3 Message Types</h3>
				</div>
				<div class="panel-body">

					<div class="row">
						<div class="col-md-4">
							<div class="top-message-chart" data-top-chart="1"></div>
							<h3 class="text-center">--</h3>
						</div>
						<div class="col-md-4">
							<div class="top-message-chart" data-top-chart="2"></div>
							<h3 class="text-center">--</h3>
						</div>
						<div class="col-md-4">
							<div class="top-message-chart" data-top-chart="3"></div>
							<h3 class="text-center">--</h3>
						</div>
					</div>

				</div>
			</div>
		</div>


		<!-- Message Appearance -->
		<!-- Message Traffic and trends -->
		<div class="col-md-12">
			<div class="panel panel-default">
				<div class="panel-heading">
					<h3 class="panel-title">Messages (Appearance Heatmap and Trend)</h3>
				</div>
				<div class="panel-body">

					<div class="form-inline">
						<div class="form-group">
							<select class="form-control calendar-heatmap-messagetype"></select>
						</div>
						<div class="btn-group">
							<a href="#" class="btn btn-primary calendar-heatmap-previous">Previous</a>
							<a href="#" class="btn btn-primary calendar-heatmap-next">Next</a>
						</div>
						<a href="#" class="btn btn-warning calendar-heatmap-reset">Reset</a>
					</div>

					<hr />
					<div class="calendar-heatmap"></div>
					<hr />
					<div class="traffic-chart" style="height:380px;"></div>

				</div>
			</div>
		</div>

	</div>

</div>

@section Styles {
	@Styles.Render("~/Content/plugins/dataTables")
	@Styles.Render("~/Content/plugins/calHeatmap")

	<style>
		.cal-heatmap-container {
			margin: 0 auto;
		}

			.cal-heatmap-container .subdomain-text {
				fill: white;
				font-size: 10px;
			}

			.cal-heatmap-container .graph-rect ~ .subdomain-text {
				fill: inherit;
			}

			.cal-heatmap-container .graph-label {
				font-weight: bold;
			}

		.top-message-chart {
			height: 280px;
			margin-top: 1rem;
			width: 100%;
		}

		.vs-other-chart-pie, .vs-other-chart-line {
			height: 280px;
			margin-top: 2rem;
			width: 100%;
		}
	</style>

}

@section Scripts {
	@*Scripts.Render("~/plugins/chartJs")*@
	@Scripts.Render("~/plugins/jqcanvasjs")

	@Scripts.Render("~/bundles/momentjs")
	@Scripts.Render("~/bundles/d3v3")
	@Scripts.Render("~/bundles/plugins/calHeatmap")
	@Scripts.Render("~/plugins/dataTables")
	
	<!-- Because reasons... -->
	<script type="text/javascript" src="https://www.gstatic.com/charts/loader.js"></script>
	<script type="text/javascript" src="https://www.google.com/jsapi"></script>

	<!--Reference the SignalR library. -->
	<script src="~/Scripts/jquery.signalR-2.2.1.min.js"></script>
	<!--Reference the autogenerated SignalR hub script. -->
	<script src="~/signalr/hubs"></script>

	<script>
		(function () {

			///////////////////////////
			// Main Stuff
			///////////////////////////

			var msgTypesURL = "@Url.Action("GetMessageClasses", "Records")";
			var msgDataURL = "@Url.Action("GetDateGroupedMessages", "Records")";
			var msgTopUrl = "@Url.Action("GetTopOfMessages", "Records")";
			var msgCountryUrl = "@Url.Action("GetMessageOccuranceByCountry", "Records")";

			var messageTypes = [];

			// Libraries and Classes
			var worldMap = new GeoChartBuilder($('#regions_div')[0]);
			var topTenTbl = new TopTenCountryTable($('.topCountriesTbl'));
			var liveFeed = new LifeFeedChart($('.life-feed-chart'), {
				controls: {
					start: $('.liveFeedStart'),
					stop: $('.liveFeedStop'),
					reset: $('.liveFeedReset')
				}
			});
			var heatMap = new HeatMapBuilder('.calendar-heatmap', {
				previousSelector: ".calendar-heatmap-previous",
				nextSelector: ".calendar-heatmap-next"
			});

			// Start loading all the things!
			var defaultMsgType = "INVALIDRECIP";

			// Load the message types for the dropdown input
			LoadOptionsFromUrl(msgTypesURL, ['.calendar-heatmap-messagetype'], ["- All -"], [defaultMsgType])
				.then(function (typeData) { messageTypes = typeData; })
			;

			// Working with date/time grouped messages...
			GetData(msgDataURL)
				.then(function (data) { BuildHeatmap(data, 'month'); return data; }) // Return the data so that we can chain some more
				.then(function (data) { BuildTrafficChart(data); return data; })
				.catch(function (err) { console.log("Error", err); })
			;

			// Working with data from top message types
			GetData(msgTopUrl, { topCount: 3 })
				.then(function (data) { BuildTopMessageChart($('[data-top-chart="1"]'), data[0]); return data; }) // 1st chart
				.then(function (data) { BuildTopMessageChart($('[data-top-chart="2"]'), data[1]); return data; }) // 2nd chart
				.then(function (data) { BuildTopMessageChart($('[data-top-chart="3"]'), data[2]); }) // 3rd chart
				.catch(function (err) { console.log("Error", err); })
			;

			// Google is special, we have to wait for them to load before we can do anything with their information
			google.charts.load('current', { 'packages': ['corechart'], mapsApiKey: "AIzaSyA2apvSegRVDBwS0MoVV_8nqkfaYs9CxLA" });
			google.charts.setOnLoadCallback(function () {
				GetData(msgCountryUrl)
					.then(function (data) { worldMap.buildMap(data); return data; })
					.then(function (data) { topTenTbl.buildTable(data); return data; });
			});

			//////////////////
			// Events
			//////////////////

			// Change the source of the heatmap
			$('.calendar-heatmap-messagetype').on('change', function (e) {
				var val = $(this).val();
				GetData(msgDataURL, { typeFilter: val })
                    .catch(function (err) { console.log("Error", err); })
                    .then(function (msgData) {
                    	BuildHeatmap(msgData, calConfig ? calConfig.domain : 'month');
                    	BuildTrafficChart(msgData);
                    });
			});

			$('.calendar-heatmap-reset').on('click', function (e) {
				e.preventDefault();
				BuildHeatmap(calConfig.source, 'month');
			});

			$('.topCountryTblItem').on('click', function (e) {
				e.preventDefault();
				var countryCode = $(this).data('country-code');
			});

			//create trigger to resizeEnd event
			$(window).resize(function () {
				if (this.resizeTO) clearTimeout(this.resizeTO);
				this.resizeTO = setTimeout(function () {
					$(this).trigger('resizeEnd');
				}, 500);
			});

			//////////////////
			// Methods
			//////////////////

			var cal = null;
			var calConfig = null;
			function BuildHeatmap(data, type) {

				if (cal != null)
					cal = cal.destroy();

				cal = new CalHeatMap();

				if (!type)
					type = 'month';

				var mData = {};

				var eData = Enumerable.From(data);
				var startDate = moment(eData.FirstOrDefault().date).toDate();
				var lastDate = moment(eData.LastOrDefault().date).toDate();

				// Fill mData
				eData.ForEach(function (x) { mData[moment(x.date).unix()] = x.total; });

				// Default config
				calConfig = {
					source: data, // So we can reuse the data again and not have to call it again
					data: mData,
					itemSelector: ".calendar-heatmap",
					start: (type == 'month') ? startDate : (calConfig.start || startDate),
					minDate: startDate,
					maxDate: lastDate,

					cellSize: 30,

					legend: Enumerable.RangeTo(0, upperDomain, (upperDomain / 6)).ToArray(),
					legendColors: ["#ecf5e2", "#232181"],
					legendOrientation: "vertical",
					legendVerticalPosition: "center",
					legendCellSize: 15,
					legendMargin: [10, 20, 0, 0],

					previousSelector: ".calendar-heatmap-previous",
					nextSelector: ".calendar-heatmap-next"

				};

				if (type == "month") {
					var upperDomain = eData.GroupBy("moment($.date).startOf('day').format()", null, function (key, g) { return { date: key, total: g.Sum("$.total") }; }).Max("$.total");
					calConfig = $.extend(true, calConfig, {
						domain: "month",
						subDomain: "x_day",
						subDomainTextFormat: "%d",
						range: 2,
						domainGutter: 15,
						legend: Enumerable.RangeTo(0, upperDomain, (upperDomain / 6)).ToArray(),
						onClick: function (date, nb) {
							calConfig.start = moment(date).toDate();
							BuildHeatmap(calConfig.source, 'day', true);
						}
					});
				}

				if (type == "day") {
					var upperDomain = eData.Max("$.total");
					calConfig = $.extend(true, calConfig, {
						domain: "day",
						subDomain: "hour",
						subDomainTextFormat: "%H",
						rowLimit: 1,
						domainGutter: 0,
						cellPadding: 5,
						cellSize: 20,
						range: 7,
						verticalOrientation: true,
						legend: Enumerable.RangeTo(0, upperDomain, (upperDomain / 6)).ToArray(),
						label: { position: "left", offset: { x: 20, y: 12 }, width: 110 },
					});
				}

				cal.init(calConfig);
			}

			function BuildTrafficChart(data) {

				if (data == null) return;

				var chartData = Enumerable.From(data)
					.GroupBy("moment($.date).startOf('day').format()", null, function (key, g) {
						return { date: key, total: g.Sum("$.total") };
					})
					.Select("{ x:moment.utc($.date).toDate(), y:$.total }").ToArray();

				var regData = Enumerable.From(chartData).Select("[moment($.x).unix(), $.y]").ToArray();

				var rDataPoly = regression('polynomial', regData, 2);
				var rDataLine = regression('linear', regData);

				var polyData = Enumerable.From(rDataPoly.points).Select("{x:moment.unix($[0]).toDate(), y:$[1]}").ToArray();
				var lineData = Enumerable.From(rDataLine.points).Select("{x:moment.unix($[0]).toDate(), y:$[1]}").ToArray();

				var chartConfig = {
					toolTip: {
						shared: true  //disable here.
					},
					legend: {
						cursor: "pointer",
						itemclick: function (e) {
							e.dataSeries.visible = !(typeof (e.dataSeries.visible) === "undefined" || e.dataSeries.visible);
							e.chart.render();
						}
					},
					data: [
						{
							type: "splineArea",
							showInLegend: true,
							name: "Traffic",
							dataPoints: chartData
						},
						{
							type: "spline",
							showInLegend: true,
							name: "Curve Trend",
							markerSize: 0,
							color: "red",
							dataPoints: polyData
						},
						{
							type: "line",
							showInLegend: true,
							name: "Linear Trend",
							markerSize: 0,
							color: "black",
							dataPoints: lineData
						}
					]
				};

				var chart = $('.traffic-chart').CanvasJSChart();

				if (chart) {
					chart.options.data = chartConfig.data;
					chart.render();
				}
				else
					$('.traffic-chart').CanvasJSChart(chartConfig);

			}

			function BuildTopMessageChart(elem, data) {

				var messageClass = data.messageClass;
				var count = +data.count;
				var total = +data.total;
				var perc = parseFloat(data.perc).toFixed();

				var chartConfig = {
					animationEnabled: true,
					backgroundColor: "transparent",
					title: {
						fontColor: "#848484",
						fontSize: 70,
						horizontalAlign: "center",
						text: perc + "%",
						verticalAlign: "center"
					},
					toolTip: {
						backgroundColor: "#ffffff",
						borderThickness: 0,
						cornerRadius: 0,
						fontColor: "#424242"
					},
					data: [
						{
							explodeOnClick: false,
							innerRadius: "90%",
							radius: "90%",
							startAngle: 270,
							type: "doughnut",
							dataPoints: [
								{ y: perc, color: "#232181", toolTipContent: messageClass + ": <span>" + count + "</span>" },
								{ y: (100 - perc), color: "#ededed", toolTipContent: null }
							]
						}
					]

				};

				$(elem).CanvasJSChart(chartConfig);
				$(elem).next().text(messageClass);
			}

			//////////////////
			// Utils
			//////////////////

			function GetData(url, data) {
				if (url == undefined) return Promise.reject("No url");
				return new Promise(function (resolve, reject) {
					$.ajax({ url: url, dataType: 'json', data: data, type: (data) ? "POST" : "GET" })
					.done(function (data) { resolve(data); })
					.fail(function (err) { reject(err); });
				});
			}

			function LoadOptionsFromUrl(url, elements, emptyText, selected) {
				return GetData(url).then(function (data) {

					data = JSON.parse(data);
					data.sort();

					$.each(elements, function (ei, element) {

						if (!Array.isArray(emptyText) && emptyText != "")
							$('<option/>', { text: emptyText, value: "" }).appendTo($(element));
						else if (Array.isArray(emptyText) && emptyText[ei])
							$('<option/>', { text: emptyText[ei], value: "" }).appendTo($(element));

						$.each(data, function (i, obj) {
							$('<option/>', { value: obj, text: obj, })
								.attr("selected", (obj == selected[ei]) ? "Selected" : false)
								.appendTo($(element));
						});

					});

					return data;

				});
			}

			//////////////////
			// Classes ( I DONT CARE )
			//////////////////

			// Class to add some functionality to Google's GeoChart dohicky
			var GeoChartBuilder = function (mapElement) {
				var self = this;

				this.element = mapElement;

				this.sourceData = [];
				this.mapData = null;

				this.mapChart = null;
				this.mapOptions = {
					region: "World",
					colorAxis: {
						colors: ["#ecf5e2", "#232181"]
					},
					tooltip: {
						isHtml: true
					}
				};

				this.defaultRegion = "World";
				this.currentRegion = null;

				/////////
				// Init
				/////////

				self.mapChart = new google.visualization.GeoChart(self.element);

				///////////
				// Public Functions
				//////////

				this.loadData = function (data) {

					// Very straight forward, I am not making this to be reusable in the slightest bit, just enough to clean up code

					self.sourceData = data;

					var chartData = Enumerable.From(self.sourceData).Select(function (e) {
						return [e.country, e.total, BuildTooltipHtml(e.country, e.total)];
					}).ToArray();

					self.mapData = new google.visualization.DataTable();
					self.mapData.addColumn('string', 'Country');
					self.mapData.addColumn('number', 'Messages');
					self.mapData.addColumn({ type: 'string', role: 'tooltip', 'p': { 'html': true } });

					self.mapData.addRows(chartData);

					self.renderMap();
				}

				this.getCountryFromCode = function (code) {
					return getCountryName(code);
				};

				this.renderMap = function () {
					self.mapChart.draw(self.mapData, self.mapOptions);
				};

				this.goToRegion = function (region) {
					self.currentRegion = region || self.defaultRegion;
					self.mapOptions.region = self.currentRegion;
					self.renderMap();
				};

				//////////
				// Private Functions
				//////////

				function buildTooltipHtml(country, value) {
					return "<strong>" + self.getCountryFromCode(country) + "</strong><br/>Messages: <strong>" + value + "</strong>";
				}


				//////////
				// Events
				//////////


				//redraw graph when window resize is completed
				$(window).on('resizeEnd', function () { self.renderMap(); });

				// Click on a region, zoom into it
				google.visualization.events.addListener(self.mapChart, "regionClick", function (e) {
					var newRegion = (e.region != self.currentRegion) ? e.region : null;
					self.goToRegion(newRegion);
				});

			};

			// Class to display the top ten countries, might as well right?
			var TopTenCountryTable = function (tblElement) {
				var self = this;

				this.element = tblElement;
				this.sourceData = [];

				this.buildTable = function (data) {

					self.sourceData = data;

					var tBody = self.element.find('tbody');

					Enumerable.From(data).OrderByDescending("$.total").Take(10).ForEach(function (item, index) {
						var tr = $('<tr/>');
						var a = $('<a/>', { 'data-country-code': item.country }).addClass('topCountryTblItem').text(getCountryName(item.country));

						$('<td/>').text((index + 1)).appendTo(tr);
						$('<td/>').append(a).end().appendTo(tr);
						$('<td/>').text(item.total).appendTo(tr);

						tr.appendTo(tBody);
					});

				};

			};

			// SignalR driven life-feed chart, this encapsulates it all
			var LifeFeedChart = function (chartElement, config) {
				var self = this;

				var defaultOptions = {
					controls: {
						play: null,
						stop: null,
						reset: null,
					}
				};
				var options = $.extend(true, defaultOptions, config);
				this.element = chartElement;
				this.hub = $.connection.logRecordTickerHub;

				this.chart = null;
				this.data = [];

				this.PlayFeed = function () { self.hub.server.startListening(); };
				this.StopFeed = function () { self.hub.server.stopListening(); };
				this.ResetFeed = function () { self.hub.server.reset(); };

				this.clearData = function () { self.data.length = 0; };
				this.addData = function (x, y) { self.data.push({ x: x, y: y }); };
				this.trimData = function (len) { if (self.data.length > len) self.data.shift(); };

				this.renderChart = function () {
					if (!self.chart) return;
					self.chart.render();
				};

				//////////////
				// Hub Stuff
				//////////////

				self.hub.client.tickerStarted = function () {
					console.log('Live Feed Started');
				};
				self.hub.client.tickerStopped = function () {
					console.log('Live Feed Stopped');
					self.clearData();
				};
				self.hub.client.tickerReset = function () {
					console.log('Live Feed Reset');
					self.clearData();
				};
				self.hub.client.tickerUpdate = function (record) {

					if (!self.chart) return;

					self.trimData(100);
					self.addData(moment.utc(record.Item1).toDate(), record.Item2);
					self.renderChart();
				};

				$.connection.hub.start().done(function () {

					if (options.controls.play) options.controls.play.on('click', function (e) { e.preventDefault(); self.PlayFeed(); });
					if (options.controls.stop) options.controls.stop.on('click', function (e) { e.preventDefault(); self.StopFeed(); });
					if (options.controls.reset) options.controls.reset.on('click', function (e) { e.preventDefault(); self.ResetFeed(); });

					self.chart = self.element.CanvasJSChart({
						toolTip: {
							contentFormatter: function (e) {
								var x = e.entries[0].dataPoint.x;
								var y = e.entries[0].dataPoint.y;
								return moment(x).format("MM/DD/YYYY h:mm A") + "<br/>Count: <strong>" + y + "</strong>";
							}
						},
						data: [{
							type: 'splineArea',
							dataPoints: []
						}]
					});

				});

			};

			// Class to display message counts in an heatmap
			var HeatMapBuilder = function (element, config) {

				var self = this;
				this.element = element;

				var defaults = {
					previousSelector: ".calendar-heatmap-previous",
					nextSelector: ".calendar-heatmap-next"
				};
				var options = $.extend(true, defaults, config);

				this.sourceData = null;
				this.data = {};
				this.currentView = "month";
				this.chart = new CalHeatMap();

				this.chartDefaultOptions = {
					data: self.data,
					itemSelector: self.element,
					cellSize: 30,
					legendColors: ["#ecf5e2", "#232181"],
					legendOrientation: "vertical",
					legendVerticalPosition: "center",
					legendCellSize: 15,
					legendMargin: [10, 20, 0, 0],

					// These need to fill out by the data and getOptions
					start: null,
					minDate: null,
					maxDate: null,
					legend: null,

					previousSelector: options.previousSelector,
					nextSelector: options.nextSelector
				};

				this.loadData = function (data) { 
					var eData = Enumerable.From(data);
					this.sourceData = eData;

					var startDate = moment(eData.FirstOrDefault().date).toDate();
					var lastDate = moment(eData.LastOrDefault().date).toDate();
					eData.ForEach(function (x) { self.data[moment(x.date).unix()] = x.total; });

					self.chartDefaultOptions.start = (this.currentView == 'month') ? startDate : (self.chartDefaultOptions.start || startDate);
					self.chartDefaultOptions.minDate = startDate;
					self.chartDefaultOptions.maxDate = lastDate;
				};

				this.render = function (view) {
					var viewOptions = getOptions(view);
					self.chart.init(viewOptions);
				};

				function getOptions(view) {
					return $.extend(true, self.chartDefaultOptions, (view != "month") ? getDayOptions() : getMonthOptions());
				};
				function getMonthOptions() {
					var upperDomain = self.sourceData.GroupBy("moment($.date).startOf('day').format()", null, function (key, g) { return { date: key, total: g.Sum("$.total") }; }).Max("$.total");
					return {
						domain: "month",
						subDomain: "x_day",
						subDomainTextFormat: "%d",
						range: 2,
						domainGutter: 15,
						legend: Enumerable.RangeTo(0, upperDomain, (upperDomain / 6)).ToArray(),
						onClick: function (date, nb) {
							self.chartDefaultOptions.start = moment(date).toDate();
							self.render('day');
						}
					};
				};
				function getDayOptions() {
					var upperDomain = self.sourceData.Max("$.total");
					return {
						domain: "day",
						subDomain: "hour",
						subDomainTextFormat: "%H",
						rowLimit: 1,
						domainGutter: 0,
						cellPadding: 5,
						cellSize: 20,
						range: 7,
						verticalOrientation: true,
						legend: Enumerable.RangeTo(0, upperDomain, (upperDomain / 6)).ToArray(),
						label: { position: "left", offset: { x: 20, y: 12 }, width: 110 },
					}
				};

			};

		})();
	</script>

}